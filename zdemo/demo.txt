 export type  LoginFormInputs ={
   mobileNumber: string;
    password: string;
  }

 export type LoginFormErrors = {
   mobileNumber?: string;
    password?: string;
}

src/screens/Welcome/Welcome.styles.ts
container: {
  flex: 1,
  justifyContent: 'center',
  alignItems: 'center',
  backgroundColor: '#B2D8D8',
  // width: 450,
  // height: 750,
},

src/screens/Login/Login.tsx

import Button from '../../components/Button/Button';
import InputField from '../../components/InputField/InputField';
import { LoginFormErrors, LoginFormInputs } from '../../types/LoginCredentials';
import React, { useState } from 'react';
import { styles } from './Login.styles';
import { View, Image, Text, TouchableOpacity, Alert } from 'react-native';
import LoadingScreen from '../Loading/LoadingScreen';
import { login } from './Login.handler';


const LoginScreen = () => {
  const [form, setForm] = useState<LoginFormInputs>({ mobileNumber: '', password: '' });
  const [errors, setErrors] = useState<LoginFormErrors>({
    mobileNumber: '',
    password: '',
  });
  const [isLoading, setLoading] = useState(false);
  const handleChange = (field: string, value: string) => {
    setForm((prevValues) => ({
        ...prevValues,
        [field]: value,
    }));
    setErrors((prevValues) => ({
        ...prevValues,
        [field]: '',
    }));
  };

  const setErrorMessage = (field: string, message: string) => {
    setErrors((prevValues) => ({
      ...prevValues,
      [field]: message,
    }));
  };


  const validateForm = () => {
    let isValid = true;

    if (!form.mobileNumber.trim()) {
      setErrorMessage('mobileNumber', 'Mobile number is required');
      isValid = false;
    }
    if (!form.password) {
      setErrorMessage('password', 'Password is required');
      isValid = false;
    }
    return isValid;
  };


  const clearFields = () => {
    setForm({
      mobileNumber: '',
      password: '',
    });
    setErrors({
      mobileNumber: '',
      password: '',
    });
  };

  const handleLogin = async () => {
    if (!validateForm()) {
        return;
    }
    // const formData = new FormData();
    // formData.append('mobileNumber', form.mobileNumber);
    // formData.append('password', form.password);
    // console.log(formData);

    try{
      setLoading(true);

      const response = await login(form);
      const result = await response.json();
      if(response.ok) {
        Alert.alert('User Login Successfully!');
        clearFields();
        return;
      }
      Alert.alert(result.message);
      } catch(error) {
        Alert.alert('Invalid error!');
      } finally{
        setLoading(false);
    }
  };

  if(isLoading) {
    return <LoadingScreen />;
  }


  return (
    <View style={styles.container}>
      <Image
        style={styles.logoStyles}
        source={require('../../../assets/images/Applogo.png')}
        accessibilityLabel="appLogo"
      />
      <View style={styles.inputfields}>
        <InputField
          value={form.mobileNumber}
          onChangeText={(text) => handleChange('mobileNumber', text)}
          placeholder="Mobile Number"
          error={errors.mobileNumber}
          keyboardType="numeric"
        />
        <InputField
          value={form.password}
          onChangeText={(text) => handleChange('password', text)}
          placeholder="Password"
          secureTextEntry
          error={errors.password}
        />
      </View>
      <Button label="Login" onPress={handleLogin}/>
      <View style={styles.registerView}>
        <Text style={styles.text}>Don't have an account?</Text>
        <TouchableOpacity>
          <Text style={styles.registerText}>Register</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

export default LoginScreen;


src/screens/Login/Login.test.tsx

import {fireEvent, render, waitFor} from '@testing-library/react-native';
import LoginScreen from './Login';
import * as LoginHandler from './Login.handler';
import React, { act } from 'react';
import { Alert } from 'react-native';

const renderLoginScreen = ()=>{
    return render(
        <LoginScreen/>
    );
};

describe('Login Screen check', ()=>{

    let mockRegister: jest.SpyInstance;
    beforeAll(() => {
      mockRegister = jest.spyOn(LoginHandler, 'login');
    });
    beforeEach(() => {
      jest.resetAllMocks();
      jest.spyOn(Alert, 'alert').mockImplementation(() => {});
    });
    afterAll(() => {
      mockRegister.mockRestore();
    });
    test('renders app logo correctly',()=>{
      const {getByLabelText} = renderLoginScreen();
      expect(getByLabelText('appLogo')).toBeTruthy();
    });
    test('checking the input fields', ()=>{
      const {getByPlaceholderText, getByText} = renderLoginScreen();
      expect(getByPlaceholderText('Mobile Number')).toBeTruthy();
      expect(getByPlaceholderText('Password')).toBeTruthy();
      expect(getByText('Login')).toBeTruthy();
    });
    test('show validattion errors when fileds are empty', async()=>{
      const{getByText, queryByText} = renderLoginScreen();
        fireEvent.press(getByText('Login'));
            await waitFor(() => {
              expect(queryByText('Mobile number is required')).toBeTruthy();
              expect(queryByText('Password is required')).toBeTruthy();
            });
    });
    test('no errors with valid inputs', async () => {
      const { getByText, getByPlaceholderText, queryByText } = renderLoginScreen();
      fireEvent.changeText(getByPlaceholderText('Mobile Number'), '1234567890');
      fireEvent.changeText(getByPlaceholderText('Password'), 'password123');
      fireEvent.press(getByText('Login'));
      await waitFor(() => {
        expect(queryByText('Mobile number is required')).toBeFalsy();
        expect(queryByText('Password is required')).toBeFalsy();
      });
    });

    it('should give an alert on successful login with message', async () => {
      const response = {
        ok: true,
        json: async () => ({ message: 'Login Successfully' }),
      };
      mockRegister.mockResolvedValue(response);
      const { getByPlaceholderText, getByText } = renderLoginScreen();
      fireEvent.changeText(getByPlaceholderText('Mobile Number'), '1234567890');
      fireEvent.changeText(getByPlaceholderText('Password'), '1234');
      await act(async ()=> {
        fireEvent.press(getByText('Login'));
      });
      await waitFor(() => {
        expect(Alert.alert).toHaveBeenCalledWith('User Login Successfully!');
      });
  });
  it('should give an alert with error message if the API gives an error', async () => {
      const response = {
        ok: false,
        json: async () => ({ message: 'User do not exist' }),
      };
      mockRegister.mockResolvedValue(response);
      const { getByPlaceholderText, getByText } = renderLoginScreen();
      fireEvent.changeText(getByPlaceholderText('Mobile Number'), '1234567890');
      fireEvent.changeText(getByPlaceholderText('Password'), '1234');
      await act(async ()=> {
        fireEvent.press(getByText('Login'));
      });
      await waitFor(() => {
        expect(Alert.alert).toHaveBeenCalledWith('User do not exist');
      });
    });
  it('should give an alert with Invalid error shows if API throws an error', async () => {
      mockRegister.mockRejectedValue(new Error('Internal server error'));
      const { getByPlaceholderText, getByText } = renderLoginScreen();
      fireEvent.changeText(getByPlaceholderText('Mobile Number'), '5432123456');
      fireEvent.changeText(getByPlaceholderText('Password'), '1234');
      await act(async ()=> {
        fireEvent.press(getByText('Login'));
      });
      await waitFor(() => {
        expect(Alert.alert).toHaveBeenCalledWith('Invalid error!');
      });
  });
});


src/screens/Login/Login.styles.ts

container:{
  flex: 1,
  justifyContent: 'center',
  alignItems: 'center',
  // width: 450,
  // height: 750,
},


App.styles.ts
container:{
  height:'100%',
  flex: 1,
  justifyContent: 'center',
//    alignItems: 'center',
  backgroundColor:'white',
},

tsconfig.json

    'node_modules/(?!(@react-native|react-native|@react-navigation)/)',


import {fireEvent, render, waitFor} from '@testing-library/react-native';
<<<<<<< Updated upstream
import LoginScreen from './Login';
import * as LoginHandler from './Login.handler';
import React, { act } from 'react';
import { Alert } from 'react-native';
=======
import React from 'react';
import LoginScreen from './Login';
import { LoginProps } from '../../types/Navigations';

const mockNavigation = {
  replace: jest.fn(),
}as unknown as LoginProps['navigation'];

const mockRoute = {
  key: 'LoginScreen',
  name: 'LoginScreen',
  params: {},
} as unknown as LoginProps['route'];
>>>>>>> Stashed changes

const renderLoginScreen = ()=>{
    return render(
        <LoginScreen navigation={mockNavigation} route={mockRoute}/>
    );
};

import {fireEvent, render, waitFor} from '@testing-library/react-native';
import {Provider} from 'react-redux';
import store from '../../redux/store';
import Registration from './Registration';
import { RegistrationScreenProps } from '../../types/Navigations';

const mockNavigation = {
  navigate: jest.fn(),
}as unknown as RegistrationScreenProps['navigation'];

const mockRoute = {
  key: 'Registration',
  name: 'RegistrationScreen',
  params: {},
} as unknown as RegistrationScreenProps['route'];

describe('Registration Screen check', () => {
  it('renders the registration screen correctly', () => {
    const {getByPlaceholderText, getByText, getByLabelText} = render(
      <Provider store={store}>
        <Registration navigation={mockNavigation} route={mockRoute} />
      </Provider>,
    );
    const image = getByLabelText('profile-image');
    expect(image).toBeTruthy();
    expect(getByPlaceholderText('First Name *')).toBeTruthy();
    expect(getByPlaceholderText('Last Name *')).toBeTruthy();
    expect(getByPlaceholderText('Email')).toBeTruthy();
    expect(getByPlaceholderText('Mobile Number *')).toBeTruthy();
    expect(getByPlaceholderText('Password *')).toBeTruthy();
    expect(getByPlaceholderText('Confirm Password *')).toBeTruthy();
    expect(getByText('Register')).toBeTruthy();
  });
  it('shows validation errors when fields are empty', async () => {
    const {getByText, queryByText} = render(
      <Provider store={store}>
        <Registration navigation={mockNavigation} route={mockRoute} />
        </Provider>,
    );


        expect(mockNavigation.replace).toHaveBeenCalledWith('RegistrationScreen');



// jest.mock('react-native-image-crop-picker', () => ({
//   openPicker: jest.fn().mockResolvedValue({ path: '/image.png' }),
// }));

// jest.mock('react-native-permissions', () => ({

// }));

// jest.mock('react-native-encrypted-storage', () => ({
//   setItem: jest.fn(),
//   getItem: jest.fn(),
//   removeItem: jest.fn(),
//   getAllKeys: jest.fn(),
//   clear: jest.fn(),
// }));


import React from 'react';
import { render } from '@testing-library/react-native';
import SplashScreen from 'react-native-splash-screen';
import App from './App.tsx';

const renderApp = () => {
  return render(<App />);
};

jest.mock('react-native-splash-screen', () => ({
  hide: jest.fn(),
}));


test('Should call SplashScreen hide method on mounting',  () => {
  renderApp();
  expect(SplashScreen.hide).toHaveBeenCalled();
});









import React, { useState } from 'react';
import { Alert, Image, KeyboardAvoidingView, Platform, ScrollView, Text, TouchableOpacity, View } from 'react-native';
import EncryptedStorage from 'react-native-encrypted-storage';
import LoadingScreen from '../Loading/Loading';
import { useNavigation } from '@react-navigation/native';
import { useDispatch, useSelector } from 'react-redux';
import Button from '../../components/Button/Button';
import InputField from '../../components/InputField/InputField';
import { ProfilePicturePickerModal } from '../../components/ProfilePicturePickerModal/ProfilePicturePickerModal';
import { register } from './Registration.handler';
import { getStyles } from './Registration.styles';
import { InputUser } from '../../types/InputUser';
import { RegistrationScreenNavigationProps } from '../../types/Navigations';
import { UploadImage } from '../../types/UploadImage';
import { Dispatch } from 'redux';
import { useAppTheme } from '../../hooks/appTheme';
import { Theme } from '../../utils/themes';
import { storeState } from '../../redux/store';
import { setUserDetails } from '../../redux/reducers/user.reducer';

const Registration = () => {
  const navigation = useNavigation<RegistrationScreenNavigationProps>();

    const theme: Theme = useAppTheme();
    const styles = getStyles(theme);

  const [showProfilePicSelectModal, setShowProfilePicSelectModal] = useState(false);
  const [profilePic, setProfilePic] = useState<UploadImage | null | string>(null);
  const [isLoading, setLoading] = useState(false);
  const userDetails = useSelector((state: storeState) => state.user);
  const [user, setUser] = useState<InputUser>({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    mobileNumber: '',
    confirmPassword: '',
  });
  const dispatch: Dispatch = useDispatch();
  const [inputErrors, setInputErrors] = useState<InputUser>({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: '',
    mobileNumber: '',
  });

  const handleChange = (field: string, value: string) => {
    setUser((prevValues) => ({
        ...prevValues,
        [field]: value,
    }));
    setInputErrors((prevValues) => ({
        ...prevValues,
        [field]: '',
    }));
  };

  const setErrorMessage = (field: string, message: string) => {
    setInputErrors((prevValues) => ({
      ...prevValues,
      [field]: message,
    }));
  };

  const validateFields = () => {
    let isValid = true;

    if (!user.firstName.trim()) {
      setErrorMessage('firstName', 'First name is required');
      isValid = false;
    }
    if (!user.lastName.trim()) {
      setErrorMessage('lastName', 'Last name is required');
      isValid = false;
    }
    if (user.email) {
      const emailRegex = /^[\w-.]+@([\w-]+\.)+[\w-]{2,}$/;
      if (!emailRegex.test(user.email)) {
        setErrorMessage('email', 'Invalid email address');
        isValid = false;
      }
    } else {
      setErrorMessage('email', 'Email is required');
      isValid = false;
    }
    if (!user.mobileNumber.trim()) {
      setErrorMessage('mobileNumber', 'Mobile number is required');
      isValid = false;
    }
    if (!user.password) {
      setErrorMessage('password', 'Password is required');
      isValid = false;
    }
    if (user.password !== user.confirmPassword) {
      setErrorMessage('confirmPassword', 'Passwords do not match');
      isValid = false;
    }
    return isValid;
  };

  const clearFields = () => {
    setUser({
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      mobileNumber: '',
      confirmPassword: '',
    });
    setProfilePic(null);
    setInputErrors({
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      mobileNumber: '',
      confirmPassword: '',
    });
  };
  const handleRegister = async() => {
    if(!validateFields()) {
      return;
    }
    const formData = new FormData();
    formData.append('firstName', user.firstName);
    formData.append('lastName', user.lastName);
    formData.append('email', user.email);
    formData.append('mobileNumber', user.mobileNumber);
    formData.append('password', user.password);
    if(profilePic) {
      formData.append('profilePicture', profilePic);
    }

    try{
      setLoading(true);
      const response = await register(formData);
      const result = await response.json();
      if(response.ok) {
        Alert.alert('You’ve successfully joined SmartChat!');
        clearFields();
        dispatch(setUserDetails(result.user));
        await EncryptedStorage.setItem(
            userDetails.mobileNumber,
            JSON.stringify({
              access_token: result.access_token,
              refresh_token: result.refresh_token,
            })
         );
         await EncryptedStorage.setItem(
          'User Data',
          JSON.stringify(result.user)
        );
        navigation.replace('Tabs');
        return;
      }
      Alert.alert(result.message);
    } catch(error) {
      Alert.alert('Something went wrong. Please try again');
      clearFields();
    } finally{
      setLoading(false);
    }
  };

  if(isLoading) {
    return <LoadingScreen />;
  }

  return (
    <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={styles.container}>
      <ScrollView contentContainerStyle={styles.body}>
      <TouchableOpacity onPress={() => {setShowProfilePicSelectModal(true);}}>
        <Image
          style={styles.img}
          source={profilePic ? typeof profilePic === 'string' ? {uri: profilePic} : {uri: profilePic.uri} : require('../../../assets/images/profileImage.png')}
          accessibilityLabel="profile-image"
          resizeMode="cover"
        />
      </TouchableOpacity>

      <View style={styles.inputfields}>
        <InputField
          value={user.firstName}
          onChangeText={(text) => { handleChange('firstName', text); }}
          placeholder="First Name"
          error={inputErrors.firstName}
          required
        />
        <InputField
          value={user.lastName}
          onChangeText={(text) => { handleChange('lastName', text); }}
          placeholder="Last Name"
          error={inputErrors.lastName}
          required
        />
        <InputField
          value={user.email}
          onChangeText={(text) => { handleChange('email', text); }}
          placeholder="Email"
          error={inputErrors.email}
        />
        <InputField
          value={user.mobileNumber}
          onChangeText={(text) => { handleChange('mobileNumber', text); }}
          placeholder="Mobile Number"
          error={inputErrors.mobileNumber}
          required
        />
        <InputField
          value={user.password}
          onChangeText={(text) => { handleChange('password', text); }}
          placeholder="Password"
          secureTextEntry
          error={inputErrors.password}
          required
        />
        <InputField
          value={user.confirmPassword}
          onChangeText={(text) => { handleChange('confirmPassword', text); }}
          placeholder="Confirm Password"
          secureTextEntry
          error={inputErrors.confirmPassword}
          required
        />
      </View>

      <View style={styles.loginView}>
        <Text style={styles.text}>Already have an account?</Text>
        <TouchableOpacity onPress={() => navigation.replace('LoginScreen')}>
          <Text style={styles.loginText}>Login</Text>
        </TouchableOpacity>
      </View>

      <Button label="Register" onPress={handleRegister} />
      <ProfilePicturePickerModal
        isEditingProfilePicture={showProfilePicSelectModal}
        close={() => {setShowProfilePicSelectModal(false);}}
        profilePicture={profilePic}
        openedFrom="registration"
        setProfilePic={setProfilePic}
      />
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default Registration;




import React, { useState } from 'react';
import { Alert, Image, KeyboardAvoidingView, Platform, ScrollView, Text, TouchableOpacity, View } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import EncryptedStorage from 'react-native-encrypted-storage';
import { useDispatch, useSelector } from 'react-redux';
import { Dispatch } from 'redux';
import Button from '../../components/Button/Button';
import InputField from '../../components/InputField/InputField';
import LoadingScreen from '../Loading/Loading';
import { login } from './Login.handler';
import { getStyles } from './Login.styles';
import { Credentials } from '../../types/Credentials';
import { RegistrationScreenNavigationProps } from '../../types/Navigations';
import { useAppTheme } from '../../hooks/appTheme';
import { Theme } from '../../utils/themes';
import { storeState } from '../../redux/store';
import { setUserDetails } from '../../redux/reducers/user.reducer';


const LoginScreen = () => {
  const navigation = useNavigation<RegistrationScreenNavigationProps>();

  const theme: Theme = useAppTheme();
  const styles = getStyles(theme);

  const [credentials, setCredentials] = useState<Credentials>({ mobileNumber: '', password: '' });
  const [errors, setErrors] = useState<Credentials>({
    mobileNumber: '',
    password: '',
  });
  const [isLoading, setLoading] = useState(false);

  const dispatch: Dispatch = useDispatch();
  const userDetails = useSelector((state: storeState) => state.user);

  const handleChange = (field: string, value: string) => {
    setCredentials((prevValues) => ({
        ...prevValues,
        [field]: value,
    }));
    setErrors((prevValues) => ({
        ...prevValues,
        [field]: '',
    }));
  };

  const setErrorMessage = (field: string, message: string) => {
    setErrors((prevValues) => ({
      ...prevValues,
      [field]: message,
    }));
  };


  const validateForm = () => {
    let isValid = true;

    if (!credentials.mobileNumber.trim()) {
      setErrorMessage('mobileNumber', 'Mobile number is required');
      isValid = false;
    }
    if (!credentials.password) {
      setErrorMessage('password', 'Password is required');
      isValid = false;
    }
    return isValid;
  };


  const clearFields = () => {
    setCredentials({
      mobileNumber: '',
      password: '',
    });
    setErrors({
      mobileNumber: '',
      password: '',
    });
  };

  const handleLogin = async () => {
    if (!validateForm()) {
        return;
    }
    try{
      setLoading(true);
      const response = await login(credentials);
      const result = await response.json();
      if(response.ok) {
        Alert.alert('You’ve successfully logged in to SmartChat!');
        clearFields();
        dispatch(setUserDetails(result.user));
        await EncryptedStorage.setItem(
            userDetails.mobileNumber,
            JSON.stringify({
              access_token: result.access_token,
              refresh_token: result.refresh_token,
            })
        );
        await EncryptedStorage.setItem(
          'User Data',
          JSON.stringify(result.user)
        );
        navigation.replace('Tabs');
        return;
      }
      Alert.alert(result.message);
      } catch(error) {
        Alert.alert('Something went wrong. Please try again');
        clearFields();
      } finally{
        setLoading(false);
    }
  };

  if(isLoading) {
    return <LoadingScreen />;
  }


  return (
 <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={styles.container}>
    <ScrollView contentContainerStyle={styles.body}>
      <Image
        style={styles.logoStyles}
        source={require('../../../assets/images/Applogo.png')}
        accessibilityLabel="appLogo"
      />
      <View style={styles.inputfields}>
        <InputField
          value={credentials.mobileNumber}
          onChangeText={(text) => handleChange('mobileNumber', text)}
          placeholder="Mobile Number"
          error={errors.mobileNumber}
          keyboardType="numeric"
        />
        <InputField
          value={credentials.password}
          onChangeText={(text) => handleChange('password', text)}
          placeholder="Password"
          secureTextEntry
          error={errors.password}
        />
      </View>
      <Button label="Login" onPress={handleLogin}/>
      <View style={styles.registerView}>
        <Text style={styles.text}>Don't have an account?</Text>
        <TouchableOpacity onPress={() => navigation.replace('RegistrationScreen')}>
          <Text style={styles.registerText}>Register</Text>
        </TouchableOpacity>
      </View>
    </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default LoginScreen;
















// __tests__/screens/Contact.test.tsx
import React from 'react';
import { render, waitFor, fireEvent } from '@testing-library/react-native';
import { Contact as ContactScreen } from '../../screens/Contact/Contact';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import EncryptedStorage from 'react-native-encrypted-storage';
import Contacts from 'react-native-contacts';
import * as permissions from '../../permissions/permissions';
import * as getContactUtils from '../../utils/getContactsDetails';

jest.mock('react-native-encrypted-storage');
jest.mock('react-native-contacts');
jest.mock('../../permissions/permissions');
jest.mock('../../utils/getContactsDetails');

const mockStore = configureStore([thunk]);

describe('Contact Screen', () => {
  let store: any;
  const accessToken = 'fake-token';

  const sampleDeviceContacts = [
    {
      givenName: 'John',
      familyName: 'Doe',
      middleName: '',
      phoneNumbers: [{ number: '+91 99999 88888' }],
    },
  ];

  const sampleResultantContacts = [
    {
      name: 'John Doe',
      mobileNumber: '9999988888',
      doesHaveAccount: true,
      profilePicture: null,
    },
  ];

  beforeEach(() => {
    store = mockStore({
      contacts: { contacts: [] },
      user: { mobileNumber: '9999988888' },
    });

    (EncryptedStorage.getItem as jest.Mock).mockResolvedValue(JSON.stringify({ access_token: accessToken }));
    (permissions.requestPermission as jest.Mock).mockResolvedValue(true);
    (Contacts.getAll as jest.Mock).mockResolvedValue(sampleDeviceContacts);
    (getContactUtils.getContactsDetails as jest.Mock).mockResolvedValue(sampleResultantContacts);
  });

  it('renders and loads SmartChat contacts correctly', async () => {
    const { getByText, queryByText } = render(
      <Provider store={store}>
        <ContactScreen />
      </Provider>
    );

    await waitFor(() => {
      expect(getByText('Contacts on SmartChat')).toBeTruthy();
      expect(getByText('John Doe')).toBeTruthy();
      expect(queryByText('Invite to SmartChat')).toBeTruthy();
    });
  });

  it('switches to Invite tab and shows non-app contacts', async () => {
    // Replace the contacts to simulate an "invite" case
    (getContactUtils.getContactsDetails as jest.Mock).mockResolvedValue([
      {
        name: 'Jane Smith',
        mobileNumber: '8888877777',
        doesHaveAccount: false,
        profilePicture: null,
      },
    ]);

    const { getByText, findByText } = render(
      <Provider store={store}>
        <ContactScreen />
      </Provider>
    );

    await waitFor(() => expect(getByText('Contacts on SmartChat')).toBeTruthy());

    fireEvent.press(getByText('Invite to SmartChat'));

    const invitedContact = await findByText('Jane Smith');
    expect(invitedContact).toBeTruthy();
  });

  it('shows alert if permission denied', async () => {
    (permissions.requestPermission as jest.Mock).mockResolvedValue(false);

    const alertMock = jest.spyOn(global, 'Alert').mockImplementation(() => {});
    render(
      <Provider store={store}>
        <ContactScreen />
      </Provider>
    );

    await waitFor(() => {
      expect(alertMock).toHaveBeenCalledWith('Permission Denied');
    });
  });

  it('shows alert on fetch failure', async () => {
    (Contacts.getAll as jest.Mock).mockRejectedValue(new Error('Error'));

    const alertMock = jest.spyOn(global, 'Alert').mockImplementation(() => {});
    render(
      <Provider store={store}>
        <ContactScreen />
      </Provider>
    );

    await waitFor(() => {
      expect(alertMock).toHaveBeenCalledWith('Failed to load contacts from device.');
    });
  });
});




// __tests__/utils/getContactsDetails.test.ts
import { getContactsDetails } from '../../utils/getContactsDetails';

global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () =>
      Promise.resolve([
        { mobileNumber: '9999988888', doesHaveAccount: true, profilePicture: null },
      ]),
  })
) as jest.Mock;

describe('getContactsDetails', () => {
  const mockContacts = [
    {
      givenName: 'John',
      middleName: '',
      familyName: 'Doe',
      phoneNumbers: [{ number: '+91 99999 88888' }],
    },
  ];

  it('returns enriched contacts', async () => {
    const result = await getContactsDetails(mockContacts as any, 'token');

    expect(result).toEqual([
      {
        name: 'John Doe',
        mobileNumber: '9999988888',
        doesHaveAccount: true,
        profilePicture: null,
      },
    ]);
  });
});






  it('shows fallback message when no device contacts are available', async () => {
    (requestPermission as jest.Mock).mockResolvedValue(true);
    (EncryptedStorage.getItem as jest.Mock).mockResolvedValue(
      JSON.stringify({ access_token: 'access_token' })
    );
    (Contacts.getAll as jest.Mock).mockResolvedValue([]);
    (getContactsDetails as jest.Mock).mockResolvedValue([]);

    const { getByText } = renderContactScreen();

    await waitFor(() => {
      expect(
        getByText('Add your friends to contacts and invite them to SmartChat')
      ).toBeTruthy();
    });
  });


    it('displays appropriate message if no filtered contacts are found on selected tab', async () => {
    const emptyContacts = [
      { name: 'A', mobileNumber: '123', doesHaveAccount: true, profilePicture: null },
    ];

    (requestPermission as jest.Mock).mockResolvedValue(true);
    (EncryptedStorage.getItem as jest.Mock).mockResolvedValue(
      JSON.stringify({ access_token: 'access_token' })
    );
    (Contacts.getAll as jest.Mock).mockResolvedValue(emptyContacts);
    (getContactsDetails as jest.Mock).mockResolvedValue(emptyContacts);

    const { getByText } = renderContactScreen();

    // Switch to Invite tab where no contacts without an account exist
    await waitFor(() => {
      fireEvent.press(getByText('Invite to SmartChat'));
    });


      it('displays appropriate message if no filtered contacts are found on selected tab', async () => {
    const emptyContacts = [
      { name: 'A', mobileNumber: '123', doesHaveAccount: true, profilePicture: null },
    ];

    (requestPermission as jest.Mock).mockResolvedValue(true);
    (EncryptedStorage.getItem as jest.Mock).mockResolvedValue(
      JSON.stringify({ access_token: 'access_token' })
    );
    (Contacts.getAll as jest.Mock).mockResolvedValue(emptyContacts);
    (getContactsDetails as jest.Mock).mockResolvedValue(emptyContacts);

    const { getByText } = renderContactScreen();

    // Switch to Invite tab where no contacts without an account exist
    await waitFor(() => {
      fireEvent.press(getByText('Invite to SmartChat'));
    });
    expect(
      getByText('All your contacts are on SmartChat. Continue your conversations with them')
    ).toBeTruthy();
  });
